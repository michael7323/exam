// в данный файл нужно добавлять решения и по возможности исправлять чужие

/*Задача 1 )
Ваня Штерн хочет купить некоторое вещество.Дилеры продают либо за BTC, либо за Ethereum.
У Вани есть некоторое количество валюты BTC и некоторое Ethereum, но в силу некоторых причин
Ваня не хочет покупать у одного и того же дилера за обе валюты.Помогите Ване правильно организовать закупку.
Реализуйте функцию double MaxSubstance(double, double, const std::vector<Dealer>&);, которая вернет
максимальное количество вещества, которое сможет купить Штерн.
У объекта типа Dealer два метода : GetBTC(), GetEthereum()
*/

double MaxSubstance(double, double, const std::vector<Dealer>&) 
{

}
void GetBTC()
{

}
void GetEthereum() 
{

}

/* Задача 2)
Необходимо реализовать класс MyInt, который будет использован для оценки эффективности 
алгоритмов сортировки.Необходимо подсчитывать количество сравнений и присваиваний.
Класс должен содержать :
Конструктор по умолчанию(по умолчанию значение 0);
Конструктор с параметром типа int(значение)
Оператор присваивания(с подсчетом количества вызовов)
Оператор сравнения < (с подсчетом количества вызовов)
	Статический метод GetAssignmentCount() - возвращает количество присваиваний
	Статический метод ResetAssignmentCount() - сбрасывает количество присваиваний
	Статический метод GetCompareCount() - возвращает количество сравнений
	Статический метод ResetCompareCount() - сбрасывает количество сравнений
	Поле static int _assignmentCount - количество присваиваний
	Поле static int _compareCount - количество сравнений
	Поле int _data - полезное значение
	*/

class MyInt 
{

};


/* Задача 3 )
Слушателям необходимо составить парты на чердаке на участок шириной 2 метра. 
Каждая парта имеет размеры 1х2 метра. Всего N парт (N ≤ 45). Сколько различных 
способов расставить эти парты?
Реализуйте функцию int DeskAllocation(int), которая вернет количество способов.
Например, одну парту можно поставить всего одним способом - вертикально
Две парты можно поставить уже двумя способами: две вертикально или две горизонтально.
Подсказка: подумайте, почему количество парт ограничено числом 45.
Еще ОЧЕНЬ жирная подсказка: подсчитайте вручную первые несколько ответов и найдите простую закономерность. 
Дальше задача решится за 5 минут.*/

int DeskAllocation(int) 
{

}

/* Задача 4 )
Реализуйте функцию int SubStrCount(const char *str, const char *subStr);,
которая подсчитывает количество вхождений подстроки subStr в строке str. 
Для поиска очередного вхождения подстроки необходимо начинать поиск, смещаясь на конечную позицию найденной подстроки.
Например, в строке «ааааааа» подстрока «аа» встречается 3 раза. Если один из параметров равен NULL, то функция должна вернуть 0.

Также реализуйте шаблонную функцию int SubStrCount(const T *str, const T *subStr);,
которая подсчитывает количество вхождений подстроки subStr в строке str. 
Для поиска очередного вхождения необходимо начинать поиск, смещаясь вправо на 1 
относительно начала найденной подстроки (считается, что строка заканчивается нулем).
Например, в строке «ааааааа» подстрока «аа» встречается 6 раз.*/

int SubStrCount(const T* str, const T* subStr) 
{

}
int SubStrCount(const char* str, const char* subStr) 
{

}

/* Задача 5 )
* Ваня Штерн снова на тренировке. В ряд выставлены столбики различной высоты hi, 
необходимо допрыгать с первого до последнего. Для того, чтобы прыгнуть с i-го столбика 
на следующий столбик Ваня тратит |hi + 1 - hi| единиц энергии. Также он может прыгнуть через один столбец, 
но потратит на это 3|hi + 1 - hi| единиц энергии. После тренировки Ваня собирается в шишу, поэтому он хочет 
потратить минимальное количество энергии.
Реализуйте функцию int SuperMario(const std::vector<int>&), которая принимает контейнер с величинами hi 
и возвращает минимально возможное количество энергии, которая нужна для прохождения с первого столбика на последний.
например, если даны 3 столбика с высотами 1, 5, 10, то ответ равен 9.
Если даны 3 столбика с высотами 1, 5, 2, то выгоднее перепрыгнуть и затратить всего 3 единицы энергии.
*/

int SuperMario(const std::vector<int>&) 
{

}

/*Задача 6 )
Для своего YouTube-канала Ваня Штерн хочет провести краш-тест нового айфона Х - узнать, 
с какого этажа он разобьется. Денег у Вани немного, поэтому он смог позволить себе купить всего 2 аппарата. 
Он идёт в дом, высотой N этажей. Какое минимальное количество бросков необходимо сделать, чтобы определить,
с какого этажа телефон разбивается. Считаем, что телефоны абсолютно одинаковы и если телефон разбился при падении с K-го этажа,
то он разобьется также со всех этажей выше. Айфоны экономить не нужно (то есть разбить можно оба)
. Реализуйте функцию int GetThrowingFloor(int);, которая возвращает этаж, начиная с которого айфон разбивается 
(то есть с этого разбивается, а с этажа ниже уже нет). Параметр - количество этажей в здании.
Для проверки вам доступна функция bool CheckFloor(int);, которая возвращает true, если айфон разбился.
Количество бросаний не должно превышать минимально достаточное для гарантированного определения этажа, с которого айфон разобьется. 
То есть для дома в 100 этажей вы не должны бросать больше 14 раз. Если телефон не разбился даже с первого этажа, то верните 0.
Не забывайте, что у вас всего 2 аппарата, после разбивания обоих телефонов функция начнет всегда возвращать false
(вы ничего не кинули - ничего не разбилось).
*/

int GetThrowingFloor(int) 
{

}

/*Задача 7
Одна из важных задач при реализации программного обеспечения - фильтрация входных данных.
Если при некотором вводе программа может работать некорректно, то, поверьте, найдется такой пользователь, 
который обязательно введет такие данные. Вам поручено проверить, является ли введенная строка числом. 
Число может содержать только цифры, знак минус, одну точку или запятую (в записи десятичной дроби), 
причем точка (запятая) не может стоять в начале или в конце. Не должно быть людирующих нулей 
(только если это не дробное число с нулевой целой частью) и нулей в конце дробной части.
Реализуйте функцию bool IsValidNumber(std::string);, которая вернет true, если указанные ограничения соблюдены.*/

bool IsValidNumber(std::string) 
{

}